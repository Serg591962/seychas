#### **Основные понятия**
1. **Репозиторий** — это хранилище исходного кода, в котором можно отслеживать изменения.
- **Удалённый репозиторий** — копия на сервере.
- **Локальный репозиторий** — копия на компьютере разработчика.**Коммит (commit)** — зафиксированное состояние кода на определённый момент времени.
2. **Ветки (branches)** — параллельные версии изменений кода.
3. Рабочий процесс Git разделен на **три состояния:**
   - **Рабочий каталог** — файлы в текущей директории.
   - **Промежуточная область (staging area)** — файлы, подготовленные к коммиту.
   - **Каталог Git (репозиторий)** — сохранённые снимки изменений.

Git использует 4 типа объектов для хранения данных:
- **Блобы (blobs):** содержат содержимое файлов.
- **Деревья (trees):** описывают структуру директорий.
- **Коммиты:** хранят метаданные и ссылки на соответствующее дерево.
- **Теги (tags):** присваивают имена коммитам.

**Клонировать** (clone) — то есть просто скопировать на локальный компьютер или сервер;
**Форкнуть** - сделать отдельную копию репозитория (обычно чужого) для продолжения разработки «по другому пути развилки».
- **Git config** - используется для настройки параметров Git, таких как имя пользователя, электронная почта и другие параметры конфигурации
- **Git init** - инициализирует новый репозиторий Git в текущей директории. Создает скрытую папку .git, которая содержит все данные о репозитории
- **Git add** - добавляет изменения в индекс (staging area), чтобы подготовить их к коммиту.
- **Git diff** - показывает различия между текущими изменениями в рабочей директории и последним коммитом. Это полезно для проверки изменений перед коммитом
- **Git commit** - сохраняет изменения в локальном репозитории, создавая новый коммит с добавленными в индекс файлами
- **Git clone** - клонирование репозитория:
- **Git reset** - отменяет изменения, которые были добавлены в индекс или коммиты. Есть несколько вариантов использования:
- **Git status** - показывает текущее состояние репозитория, например, какие файлы были изменены, какие из них добавлены в индекс, и какие изменения еще не были закоммичены. 
- **Git merge** - сливает изменения из одной ветки в другую. Это используется, когда нужно объединить работу нескольких веток
- **Git push** - используется для отправки содержимого локального репозитория в удаленный репозиторий.
- **Git pull** - используется для получения и интеграции изменений из удаленного репозитория в текущую ветку локального репозитория. Это комбинация двух команд: Git fetch (для загрузки изменений с удаленного репозитория) и Git merge (для объединения этих изменений с локальной веткой).
#### **Установка GIT**
- скачать с официального сайта https://git-scm.com/
- установить
- проверить установку - git --version получаем версию Git
- **git** - получаем список доступных команд
- **git help config** - предоставляет руководство со страницы справки
#### **Настройка Git**
###### 1 Установить имя и почту:
   - git config --global user.name "Serg"`
   - `git config --global user.email "swik591962@gmail.com"`
###### 2 Установить имя ветки по умолчанию:
   - git config --global init.defaultBranch main
###### 3 Настроить окончания строк:
   - git config --global core.autocrlf true - Git полностью блокирует добавление файлов с неконсистентными окончаниями строк.
   - git config --global core.safecrlf warn - Git выдаёт предупреждение, если обнаруживает смешанные окончания строк в файле.
###### 4 Проверка настроек:
- git config --list
###### 5 Вернуться в командную строку:
Q (клавиша "q" от слова "quit")

### **Часть I: Один репозиторий**
#### **Создание Git-репозитория**
###### 1 Cоздание пустой поддиректории work, затем создание там файла hello.html
- cd /d/git/repositories - переход в папку repositories
- mkdir work - создание папки work
- mkdir /d/git/githowto/repositories/work - создание папки work
- mkdir -p projects/work - если нет папки projects она ее создаст а потом папку work
- cd work переход в папку work
- touch hello.html - создание в папке work файла hello.html
###### 2 Создание Git-репозитория из директории work.
- **git init** -> Эта команда создаёт в текущем каталоге новый подкаталог с именем .git, содержащий все необходимые файлы репозитория — структуру Git репозитория. это подготовительный этап перед фиксацией изменений.
- **git status** -> Эта команда определяет, какие файлы в каком состоянии находятся
	- git status -s =>  Вывод состояния в сокращенном виде
- **git add** - > Чтобы начать отслеживать, проиндексировать (добавить под версионный контроль) новый файл. Добавляет файл (или файлы) в индекс (также называемый "staging area") это подготовительный этап перед фиксацией изменений. Указывает Git, что хочет включить изменения в файл hello.html в следующий коммит. Этот файл добавляется в "список изменений", которые будут зафиксированы, но при этом эти изменения еще не зафиксированы в репозитории.
	- git add hello.htm -> добавляет файл (или файлы) в индекс (также называемый "staging area") это подготовительный этап перед фиксацией изменений.
	- git add . -> индексация всех изменённых и новых папок и файлов
- **git diff** ->  Эта команда показывает показывает разницу между рабочей директорией и индексом. Если ты файл добавлен(git add .), но потом не внесены новых изменений, то git diff будет пустым.
	- git diff --staged -> что вы проиндексировали и что войдёт в следующий коммит сравнивая проиндексированные изменения с последним коммитом:
- **git commit** -> Создание коммита (добавление страницы в репозиторий).
	- git commit -> открывается редактор для ввода комментария -> переводит редактор в режим INSERT  - ввод информации. В первой строке ввести комментарий: Added h1 tag. Esc -> переводит редактор в командный режим
		:wq и нажмите Enter ->  изменения сохраняются редактор закрывается
		:q! и нажмите Enter ->  изменения не сохраняются редактор закрывается
	- git commit -m "Initial Commit" -> делает комментарий "Initial Commit" создаёт "снимок" (snapshot) состояния файлов и папок, которые были добавлены в индекс (git add), и сохраняет его в истории изменений. Флаг -m позволяет указать сообщение коммита прямо в команде. Например, "Initial Commit" — это сообщение, описывающее сделанные изменения, чтобы другие разработчики могли понять, что изменилось. Все файлы из индекса фиксируются в репозитории. Git сохраняет их текущее состояние как "точку восстановления", к которой можно вернуться.
###### 3 Проверка состояния  и удаление репозитория
- **git status** -> On branch main nothing to commit, working tree clean
	- **On branch main:** Вы находитесь в ветке `main`. Это основная ветка вашего репозитория, если вы не создавали новые ветки. Ветки в Git используются для изоляции работы над различными изменениями.
	- **nothing to commit:** В вашем индексе (staging area) нет изменений, которые нужно зафиксировать. Это значит, что вы не добавляли новых файлов или не вносили изменений в уже отслеживаемые файлы.
	- **working tree clean:** Рабочая директория чистая - это значит, что все файлы в вашей папке соответствуют последнему состоянию, зафиксированному в репозитории. Нет неотслеживаемых, изменённых или удалённых файлов.
- rm -rf .git -> удаляет только папку .git, но оставляет файлы проекта
- cd .. -> перейти на уровень выше удаляемой папки
  rm -rf work -> удаляет репозиторий и папку
#### **Внесение изменений**
###### 1 Удаление и восстановлением закомиченных файлов
-  git rm hello.html - > удаляет файл `hello.html` как из рабочей директории, так и из индекса (staging area). При следующем коммите изменения зафиксируют факт удаления файла из проекта.
- git checkout HEAD -> покажет какие изменения произошли после последнего коммита
- git checkout HEAD -- hello.html ->  восстановит файл из последнего коммита
- git restore hello.html -> восстановит файл из последнего коммита (аналог git checkout HEAD -- hello.html)
###### 2 Изменить файл «hello»
Открыть и изменить в блокноте
- Проверить состояние рабочей директории.
	git status => On branch main Changes not staged for commit:  (use "git add file..." to update what will be committed)  (use "git restore file..." to discard changes in working directory)        modified: hello.html   no changes added to commit (use "git add" and/or "git commit -a")
	- **On branch main:**  Вы работаете в ветке `main`.
	- **Changes not staged for commit:** - Это значит, что Git обнаружил изменения в файле hello.html, но вы ещё не подготовили эти изменения для фиксации.
	- **modified: hello.html:** - Файл hello.html был изменён.
	- **no changes added to commit:** - Поскольку изменения ещё не добавлены в индекс, у Git нет данных, которые он мог бы зафиксировать.
Индексация изменённых файлов
- git add .   => индексация всех изменённых и новых файлов
- git add hello.html => индексация файла hello.html
Закоммитить изменения
- git commit -> открывается редактор для ввода комментария. В первой строке ввести комментарий: Re_Commit
	Esc -> переводит редактор в командный режим
	:wq и нажмите Enter ->  изменения сохраняются редактор закрывается
	:q! и нажмите Enter ->  изменения не сохраняются редактор закрывается
- git commit -m "Re_Commit" -> делает комментарий "Re_Commit" и фиксирует изменения в репозитории.
#### **Получение списка произведенных изменений**.
- git log —  показывает историю коммитов в репозитории. 
	commit 6754b1e41953bd2d44b3c1433ec420bbb77abd45 (HEAD -> main) -> хеш коммита (уникальный идентификатор изменений), HEAD указывает на текущий коммит, (main-> это главная ветка, в которой работаем).
	Author: Serg <swik591962@gmail.com> -> автор коммита, использованный email.
	Date:   Thu Feb 7 16:12:43 2025 +0200 -> дата и время, когда был сделан коммит.
		Re_Commit -> сообщение коммита
- git log --pretty=oneline -> однострочный формат
- git log --all --pretty=format:"%h %cd %s (%an)" -> выводит коммиты за последние 7 дней с форматированием. => 418d89d Thu Feb 6 11:30:43 2025 +0200 Re_Commit (Serg)
	- all: Показывает коммиты всех веток.
	- %h: Хэш коммита (сокращенный).
	- %cd: Дата коммита.
	- %s: Сообщение коммита.
	- %an: Имя автора коммита.
	- --since="7 days ago": Показывает только коммиты, сделанные за последние 7 дней.
#### **Возвращение рабочей директории к любому предыдущему состоянию**
###### 1 Получение хешив предыдущих коммитов
- git log --pretty=format:"%h %ad | %s%d [%an]" --date=short
6754b1e 2025-02-07 | Re_Commit (HEAD -> main) [Serg] -> хеш второго коммита
8d07b38 2025-02-07 | Initial Commit [Serg] -> хеш первого коммита
- git checkout 8d07b38 => переходим в первый коммит, в состояние "detached HEAD", что означает, что  HEAD-ссылка больше не указывает на ветку, а на конкретный коммит (в данном случае на коммит с хэшем 0a77492).
- git diff -> показывает незакоммиченные изменения
- git checkout -b new-branch -> создаем новую ветку, new-branch)
###### 2 Возвращение к последней версии в ветке `main`**
- git switch main => переключение на главную ветку main, на её последнюю версию
- cat hello.html => получаем содержимое файла
Hello, World!
#### **Создание тегов версий**
###### 1 Создание тега первой версии
- git tag v1 -> создает **тег** с именем v1 на текущем коммите. Теги в Git используются для пометки определенных точек в истории проекта, обычно для версий или значимых изменений. Тег v1 может означать первую стабильную версию вашего проекта.
- git tag -a v1 -m "Version 1" ->создает  аннотированный тег (с дополнительной информацией, такой как имя автора, дата и сообщение)
- git tag v1-beta -> создает **тег** с именем v1-beta на текущем коммите предшествующим v1.
- git log --decorate -> покажет, где находятся теги, в том числе, на каких коммитах они установлены.
- git show v1 -> проверка, на какой коммит указывает тег `v`
###### 2 Теги для предыдущих версий и переключение по имени тега 
- git checkout v1 ->переключение на коммит с тегом v1
- git checkout v1^ -> переключение на коммит, предшествующий v1.
- git checkout v1-beta -> переключение на коммит  с тегом v1 - beta.
###### 3 Просмотр тегов с помощью команды tag
git tag -> выводит какие теги доступны
git log main --all -> показывает историю коммитов для ветки `main`, а также для всех других веток и тегов репозитории
commit 050d6459e2d3102f0e68141ec4397af334c77098 (tag: v1, main)
Author: Serg <swik591962@gmail.com>
Date:   Thu Jan 9 15:21:08 2025 +0200
perw Commit
commit d4fd25a761277f20ca3416215adf1c167e05ae84 (HEAD, tag: v1-beta)
Author: Serg <swik591962@gmail.com>
Date:   Tue Jan 7 14:00:12 2025 +0200
Initial Commit
#### **Отмена локальных изменений (до индексации)**
###### 1 Переключитесь на ветку main
git switch main
###### 2 Изменить файл HELLO
###### 3 Проверьте состояние
git status =>
`On branch main`
`Changes not staged for commit:`
  `(use "git add <file>..." to update what will be committed)`
  `(use "git restore <file>..." to discard changes in working directory)`
        `modified:   hello.html`
`no changes added to commit (use "git add" and/or "git commit -a")`
**файл hello.html был изменен, но еще не проиндексирован.**
###### 4 Отмена проиндексированных изменений
git checkout hello.html =>восстанавливает файла hello.html из индекса (или последнего зафиксированного состояния). Она заменит локальные изменения в файле на версию из последнего коммита.
git status -> проверка состояния
cat hello.html -> просмотр файла
##### **Отмена проиндексированных изменений (перед коммитом)**
 отменять изменения, которые были проиндексированы.
###### 1 Изменить файл и проиндексировать изменения
git add hello.html => проиндексировать изменения
git status =>
On branch main
Changes to be committed:
(use "git restore --staged `<file>..."` to unstage)
modified:   hello.html => изменение было проиндексировано и готово к коммиту
###### 2 Сброс индексации
git reset HEAD hello.html => отмена индексации
Unstaged changes after reset:
M	hello.html 
отменяется только индексация, файл назад не откатывается
###### 3 Переключитесь на версию коммита
git checkout hello.html => - Git заменяет текущую версию файла `hello.html` на его последнюю закоммиченную версию из текущей ветки. Содержимое файла `hello.html` на диске будет перезаписано на то, что хранится в последнем коммите текущей ветки.
git checkout <commit_hash> -- hello.html => - Git извлекает версию файла `hello.html` из указанного коммита и заменяет текущую версию файла. Файл на диске будет перезаписан содержимым из указанного коммита.
#### **Отмена коммитов**
###### 1 Отмена коммитов путем создания нового коммита, отменяющего нежелательные изменения.
git revert HEAD => отменяет изменения, внесенные последним коммитом (HEAD), путем создания нового коммита, который возвращает репозиторий в состояние до последнего коммита, не удаляет историю, а добавляет новый коммит с противоположными изменениями.
#### **Удаление коммитов из ветки**
###### 1 Отметим последний коммит тегом, чтобы потом можно было его найти.
git tag oops => создаёт новый **локальный тег** с именем `oops` на текущем коммите.
git log
commit 57f813729913d531149f3e3616ff30c62dc4d1fd (HEAD -> main, tag: oops)
Author: `Serg <swik591962@gmail.com>`
Date:   Fri Jan 10 16:21:32 2025 +0200
###### 2 Сброс к коммиту с тегом v1
git reset --hard v1
#### **Внесение изменений в существующие коммиты**
###### 1 Изменить файл и проиндексировать изменения
git add hello.html => проиндексировать изменения
$ git log --pretty=oneline
6754b1e41953bd2d44b3c1433ec420bbb77abd45 (HEAD -> **main, tag: v1) Re_Commit**
8d07b38d49068803f2deeed3f7220c8079ad975c (tag: v1-beta, new-branch) Initial Commit
###### 2 Изменить последний коммит без создания нового коммита.
git commit --amend -m "Changed commit"
git log --pretty=oneline
de1fd2a4ca32e3c85eddb7b36169e2dafb480aa8 (HEAD -> **main) Changed commit**
8d07b38d49068803f2deeed3f7220c8079ad975c (tag: v1-beta, new-branch) Initial Commit
#### **Создание локальной ветки в репозитории**
**git switch -c style** => 
Switched to a new branch 'style' (перешёл на новую ветку style)
- git switch -> переключение между ветками.
- -c style -> создаёт новую ветку style и сразу же на неё переключается.
git log --pretty=oneline
de1fd2a4ca32e3c85eddb7b36169e2dafb480aa8 **(HEAD -> style, main**) Changed commit
8d07b38d49068803f2deeed3f7220c8079ad975c (tag: v1-beta, new-branch) Initial Commit
#### **Закоммичевание изменений в ветке style**
touch style.css => в папке в ветке style появится файл style.css
git add style.css
git commit -m "Added css stylesheet"
git log --pretty=oneline -> получение коммитов в новой ветке
392e01858ed7a21b01ff7d72df23cd3fd96dd267 (HEAD -> style) Added css stylesheet
de1fd2a4ca32e3c85eddb7b36169e2dafb480aa8 (main) Changed commit
8d07b38d49068803f2deeed3f7220c8079ad975c (tag: v1-beta, new-branch) Initial Commit
изменить файл hello.html
git add hello.html
git commit -m "Included stylesheet into hello.html" => получаем новую ветку под названием style с двумя новыми коммитами
 git log --pretty=oneline
2d21b1b947b8934e96e48422687634e7f6b8228d (HEAD -> style) Included stylesheet into рello.html
392e01858ed7a21b01ff7d72df23cd3fd96dd267 Added css stylesheet
de1fd2a4ca32e3c85eddb7b36169e2dafb480aa8 (main) Changed commit
8d07b38d49068803f2deeed3f7220c8079ad975c (tag: v1-beta, new-branch) Initial Commit
#### **Переключение между ветками**
git switch main => переключение на ветку main
Switched to branch 'main'
git log --pretty=oneline -> видим только коммиты ветки main, так как style создавалась после последнего  коммита
de1fd2a4ca32e3c85eddb7b36169e2dafb480aa8 (HEAD -> main) Changed commit
8d07b38d49068803f2deeed3f7220c8079ad975c (tag: v1-beta, new-branch) Initial Commit
git switch style => переключение на ветку style
 git log --pretty=oneline -> видим все коммиты
2d21b1b947b8934e96e48422687634e7f6b8228d (HEAD -> style) Included stylesheet into hello.html
392e01858ed7a21b01ff7d72df23cd3fd96dd267 Added css stylesheet
de1fd2a4ca32e3c85eddb7b36169e2dafb480aa8 (main) Changed commit
8d07b38d49068803f2deeed3f7220c8079ad975c (tag: v1-beta, new-branch) Initial Commit
###### 1 Увидеть все ветки
git log --oneline --all --graph
* 2d21b1b (HEAD -> style) Included stylesheet into hello.html
* 392e018 Added css stylesheet
* de1fd2a (main) Changed commit
| * e90887a (tag: oops) Revert "Re_Commit"
| * 6754b1e (tag: v1) Re_Commit
|/
* 8d07b38 (tag: v1-beta, new-branch) Initial Commit
###### 2 Увидеть коммиты, которые есть в `style`, но нет в `main`
git log main..style --oneline
2d21b1b (HEAD -> style) Included stylesheet into hello.html
392e018 Added css stylesheet
18 Перемещение файлов**
#### **Просмотр истории изменений в конкретном файле**
###### 1 Просмотр истории коммитов в ветке
git switch main => переключение на ветку main
git log hello.html -> покажет историю коммитов ветки main, в которых фигурировал hello.html
git switch style => переключение на ветку style
git log hello.html -> покажет историю коммитов веток main и style, в которых фигурировал hello.htm до разделения
###### 2 Просмотр различий для конкретного файла
git show v1 -> Команда show используется для просмотра изменений в конкретном коммите.
tag v1 -> Указывает, что мы смотрим на изменения, связанные с тегом `v1`.
Tagger: Serg <swik591962@gmail.com> -> Имя и email пользователя, который создал этот тег.
Date:   Mon Feb 10 11:19:30 2025 +0200 -> Дата и время, когда был добавлен тег
Version 1 -> Сообщение, связанное с тегом, которое было добавлено при его создании.
commit 6754b1e41953bd2d44b3c1433ec420bbb77abd45 (tag: v1) -> Хеш коммита, в который был добавлен тег v1.
Author: Serg <swik591962@gmail.com>
Date:   Mon Feb 10 10:43:12 2025 +0200
    Re_Commit
diff --git a/hello.html b/hello.html -> Показывает, что изменения касаются файла `hello.html`.
index e69de29..b6fc4c6 100644 -> Это хеши содержимого файла до и после изменений (e69de29 - это состояние файла до изменений, b6fc4c6 - после). `100644` означает обычный файл с правами доступа для чтения и записи.
--- a/hello.html -> Указывает, что файл был изменён, и отображает различия между старой и новой версией.
+++ b/hello.html
@@ -0,0 +1 @@ -> Показывает, что изменения начинаются с первой строки файла.
- **`-0,0`**: Это означает, что в файле не было строк (до изменений).
- **`+1`**: Одна новая строка была добавлена.
+hello -> строка hello была добавлена в файл hello.html
\ No newline at end of file -> Указывает, что в конце файла не было новой строки. Это означает, что файл не заканчивается символом новой строки (например, `\n`)

#### **Переименовать файл** 
git switch style => переключение на ветку main
git mv hello.html mv_hello.html -> переименовывает файл с именем hello.html в hello.html и автоматически индексирует это изменение.
git commit -m "Renamed hello.html to mv_hello.html"
#### **Переместите style.css безопасным способом**
###### 1 Cоздание пустой поддиректории work1, затем создание там пустой поддиректории work2
- cd /d/git/repositories - переход в папку repositories
- mkdir -p work1/work2 - создаёт внутри папки папку work work1 и внутри ее папку work2
###### 2 Перемещение файла
- git mv style.css work1/work2/style.css - переместить файл style.css в work1/work2 с сохранением отслеживания Git. Эта команда гарантирует, что перемещение будет записано в истории Git как перемещение.
###### 3 Закоммитить изменения
- git commit -m "Moved style.css to work1/work2" -> фиксируем перемещение в истории:
###### 4 просмотр истории файла до его перемещения
- git log --follow -- style.css ->  Это покажет все коммиты, где файл style.css изменялся в этом репозитории. follow позволяет Git отслеживать историю файла даже если он переименовывался или перемещался внутри этого репозитория.
#### **Работа с несколькими ветками с различными (и, возможно, конфликтующими) изменениями.**
###### 1 Просмотр отличающихся веток
git log --all --graph --decorate --oneline -> отобразит, где находятся ветки, в виде дерева коммитов, представленного в виде простых текстовых линий. 
###### 2 Слияние двух отличающихся веток для переноса изменений обратно в одну ветку
git switch style => переходим в ветку style
git merge main => Эта команда возьмёт все изменения из ветки main и применит их к текущей ветке style
###### 3 Слияние при конфликте (Если в обеих ветках была изменена одна и та же часть файла)
4. вносим изменения в один и тот же файл в обоих ветках
5. git merge style -> пытаемся перенести изменения style и перенести в текущую ветку.
		получаем ошибку:
		Auto-merging mv_hello.html
		CONFLICT (content): Merge conflict in mv_hello.html
		Automatic merge failed; fix conflicts and then commit the result.
6. Открываем конфликтующий файл в блокноте.
		hello
		"Added copyright statement with email"
		<<<<<<< HEAD
		main
		=======
		 это style
		>>>>>>> style
7. Убираем все что касается stule  и оставляем main, закрываем блокнот
		hello 
		"Added copyright statement with email" main
8. git add mv_hello.html -> фиксируем изменения
9. git commit -> завершаем слияние
#### **Сброс ветки style до точки перед первым слиянием**
- git switch style переход в ветку style
- git log --graph --oneline => получаем список коммитов в краткой форме.
    *   06b13f0 (HEAD -> main) Merge branch 'style'   - коммит слияния. В нем объединяются изменения из ветки `style` в ветку `main`.
	|\                                                                                -  | - все к чему относится слияние объединяются изменения из ветки style в ветку main.
	| * 7a93015 (style) изменили style
	* | 0f16eab изменили main                                   - последний коммит перед слиянием
	|/
	* fc80c5f Moved style.css to work1/work2
	* 18d4a71 Renamed hello.html to mv_hello.html
	* 2d21b1b Included stylesheet into hello.html
	* 392e018 Added css stylesheet
	* de1fd2a Changed commit
	* 8d07b38 (tag: v1-beta, new-branch) Initial Commit
- git reset --hard 0f16eab => Это сбросит ветку к указанному коммиту. Все изменения, которые были сделаны после него (включая слияния), будут удалены. Все незакоммиченные изменения в рабочей директории также будут удалены.
#### **Перебазирование из style в main**
git switch style
git rebase main  => Эта команда временно "извлекает" коммиты из ветки style, начиная с того места, где ветка style разошлась с веткой main. Переносит эти коммиты поверх самой новой версии ветки main. Создает линейную историю, где изменения из style следуют за последним коммитом из main.
### **Часть II: Несколько репозиториев**
#### **Клонирование репозиториев**
cd /d/git/repositories/work - перейти в директорию где находится репозиторий под  названием work. который собираемся клонировать
git clone /d/git/repositories/work /d/git/repositories/home => клонировать репозиторий под названием **work** в репозиторий под названием home
cd /d/git/repositories/home => перейти в репозиторий под  названием home.
#### **Просмотр клонированного репозитория**
ls =>  видим все файлы находящиеся в клонированном репозитории
git log --all =>  видим историю, список всех коммитов в новый репозиторий, и он должен совпадать с историей коммитов в оригинальном репозитории. Единственная разница должна быть в названиях веток.
##### **Просмотр списка всех веток в репозитории**
git branch -a => отображает список всех веток в вашем репозитории, включая удалённые ветки 
#### **Удаление клонированного репозитория**
rm -rf /d/git/repositories/home => удаление папки и репозитория
ls /d/git/repositories => проверка что папки home нет 
cd /d/git/repositories/work => переход в репозиторий под  названием work.

#### **Работа при изменение оригинального репозитория**
###### 1 Изменение файла в оригинальном репозитории
cd /d/git/repositories/work => перейти в оригинальный репозиторий work:
внести изменения в файл mv_hello.html
git add .
git commit -m "Changed mv_hello.html in original repo" - сохранить изменения в оригинальном репозитории work
cd ../home => перейти в клонированный репозиторий home:
git fetch -> загружает изменения из удалённого репозитория (`origin` или другого) в локальный Git, но не меняет рабочую директорию и не сливает изменения в текущую ветку.
По сути, git fetch обновляет информацию о том, что происходит на сервере, но не трогает ваш код.
git log main..origin/main --oneline -> покажет список коммитов, которые есть на origin/main, но которых нет в вашей локальной ветке main.
git log --all --graph -> покажет состояние всех веток и коммитов, помогает увидеть визуальную структуру репозитория — все ветки, коммиты и их связи. Она помогает понять:
Какие ветки есть в проекте, какие коммиты где находятся, как ветки расходятся и сливаются, какая ветка откуда вышла и куда ведёт.
###### 2 Подтягивание изменения из удаленного репозитория в локальные ветки клонированного репозитория.
git merge origin/main - выполняет слияние локальной ветки с изменениями, которые были подтянуты с удалённой ветки origin/main (с помощью git fetch), сливает изменения из удалённой ветки в вашу текущую локальную ветку. Локальная ветка будет обновлена с учётом последних изменений из удалённого репозитория.
git pull - выполняет оба действия: сначала подтягивает изменения с помощью git fetch, а затем сливает их с текущей локальной веткой с помощью git merge.
###### 3 Добавление ветки наблюдения (добавлять локальную ветку, которая отслеживает изменения удаленной ветки.)
git switch --track origin/style - эта команда создаёт локальную ветку, которая будет отслеживать (или привязана к) удалённой ветке.
Эта команда состоит из трёх частей:
- git switch — переключает на указанную ветку.
- --track — создаёт новую локальную ветку и связывает её с удалённой.
- origin/style — это удалённая ветка, из которой создаётся локальная.
Что делает эта команда?
Проверяет, существует ли локальная ветка с таким именем (style).
Если локальной ветки style нет, Git её создаст и привяжет к origin/style.
Если ветка style уже существует, Git выдаст ошибку (что и произошло у вас).
Создаёт локальную ветку style (если её нет). Новая локальная ветка будет иметь такое же состояние, как origin/style.
Настраивает "upstream" (отслеживание) для новой ветки. Это значит, что git pull и git push будут автоматически работать с origin/style.
Переключает вас в новую ветку style.
git branch -vv - показывает локальную ветку, её текущий коммит и его описание, какую удалённую ветку она отслеживает (если вообще отслеживает).
* main  99843e8 [origin/main] Changed mv_hello.html in original repo
  style 7a93015 [origin/style] изменили style -> локальная `main` **связана с `origin/main`** и находится на коммите 99843e8
###### 4 Создание чистого репозитория
"Чистый" (или bare) репозиторий — это репозиторий без рабочей директории (без файлов проекта). Он содержит только метаданные Git, необходимые для хранения и управления версионностью. Такие репозитории обычно используются как центральное хранилище для командной работы, куда разработчики могут отправлять (git push) и получать (git pull) изменения.
10. Перемещение в нужную директорию, чтобы создать "bare" репозиторий на одном уровне с `work`, а не внутри него.
	cd ..
11. Создание "чистого" репозитория.
	git clone --bare work work.git
- git clone — создаёт копию существующего репозитория.
- --bare — делает репозиторий "чистым" (без рабочей директории).
- work — имя существующего репозитория, который вы клонируете.
- work.git — имя каталога, куда создаётся новый "bare" репозиторий.
	Что произойдёт после выполнения команды?
- Создастся папка work.git.
- Внутри будут только файлы Git, но не будет файлов проекта.
12. Проверка содержимого "bare" репозитория.
	ls work.git
###### 5 Добавление удалённого репозитория в локальный репозиторий.
Задача: Добавить "чистый" (bare) репозиторий в качестве удалённого хранилища, чтобы отправлять в него изменения.
git remote add shared ../work.git => команда добавляет новый удалённый репозиторий и даёт ему имя shared.
git remote -v => проверяем список удалённых репозиториев:
	shared  ../work.git (fetch)
	shared  ../work.git (push) -> подтверждает, что shared теперь указывает на work.git.
###### 6 Отправка изменений в удаленный репозиторий.
git switch main => переключаемся на основную ветку main, чтобы изменения вносились именно в неё.
вручную отредактировать файл mv_hello.html
git add . => добавляет изменённый файл в **индекс (staging area)**, чтобы он вошёл в следующий коммит
git commit -m "Added shared comment to readme" => фиксация изменений в локальном репозитории
git push shared main => отправка изменений в удалённый репозиторий `shared`
###### 7 Подтягивание изменения из общего репозитория.
cd ../home => переходим в локальный репозиторий home, который связан с work.git.
git remote -v => проверит какие удалённые репозитории уже добавлены, покажет все удалённые репозитории и их соответствующие URL.
git remote add shared ../work.git => добавляем work.git как удалённый репозиторий с именем shared. Теперь мы можем получать из него изменения.
git branch --track shared main => создаёт локальную ветку shared, которая будет следить за main в shared. Теперь при выполнении git pull она автоматически будет подтягивать изменения.
git pull shared main => git pull скачивает последние изменения из удалённого репозитория shared (то есть work.git) и объединяет их с локальной веткой. Теперь локальный репозиторий home содержит актуальные данные из общего репозитория